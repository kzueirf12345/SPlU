# SPlU

Этот проект представляет собой реализацию собственного ассемблера. Он состоит из 2 больших частей - ассемблирование исходного файла в промежуточное представление, и исполнение (процессинг) полученного байт-кода. В проекте реализована видео-память с использованием библиотеки SDL2, что позволяет легче отлаживать программу, или попиксельно рисовать через работу с памятью.

## Структура проекта

Проект состоит из следующих основных компонентов:

- **assembler**: Модуль ассемблера, который преобразует текстовый код на ассемблере в бинарный формат, понятный процессору.
- **processor**: Модуль процессора, который выполняет бинарный код, сгенерированный ассемблером.
- **libs**: Библиотеки для работы со стеком и логированием, подключенные как сабмодули.
- **assets**: Папка с примерами программ на ассемблере и бинарными файлами.
- **utils**: Информация об общих конвенциях и служебные файлы для синхронизации между **assembler** и **processor**.

## Зависимости

Для успешной сборки и запуска проекта необходимо установить следующие зависимости:

- **GCC**: Компилятор для сборки проекта.
- **Make**: Утилита для управления сборкой.
- **SDL2**: Библиотека для работы с графикой и видео-памятью.

Установка зависимостей на Ubuntu:

```bash
sudo apt-get install build-essential make libsdl2-dev
```

## Сборка

Makefile проекта предоставляет команды для сборки и управления проектом, такие как:

- **Сборка всех компонентов**: `make all`
- **Сборка ассемблера**: `make assembler_build`
- **Запуск ассемблера**: `make assembler_start`
- **Сборка процессора**: `make processor_build`
- **Запуск процессора**: `make processor_start`
- **Очистка всех сгенерированных файлов**: `make clean`
- **Полная очистка проекта (включая библиотеки)**: `make clean_all`
- **Пересборка всех компонентов**: `make rebuild`
- **Сборка библиотек**: `make libs_build`
- **Очистка библиотек**: `make libs_clean`
- **Пересборка библиотек**: `make libs_rebuild`

Makefile также поддерживает флаги для отладки (`DEBUG_=1`) и релиза (`DEBUG_=0`), что позволяет гибко настраивать процесс сборки.

## Использование

> Примеры с кодом можно посмотреть в папке `./assets`. Там есть:
> - Рассчёт факториала
> - Решение квадратного уравнения
> - Отрисовка круга заданного радиуса по центру видеопамяти

Процессор поддерживает следующие операции:

- **Арифметические операции**:
  - `PUSH`: Помещает значение на стек.
  - `POP`: Извлекает значение из стека.
  - `ADD`: Сложение двух верхних элементов стека.
  - `SUB`: Вычитание двух верхних элементов стека.
  - `MUL`: Умножение двух верхних элементов стека.
  - `DIV`: Деление двух верхних элементов стека.
  - `MOD`: Остаток от деления двух верхних элементов стека.
  - `SQR`: Квадратный корень верхнего элемента стека.

- **Ввод/вывод**:
  - `IN`: Ввод числа с клавиатуры.
  - `OUT`: Вывод числа на экран.

- **Управление потоком выполнения**:
  - `JMP`: Безусловный переход.
  - `JL`: Переход, если первый элемент стека меньше второго.
  - `JLE`: Переход, если первый элемент стека меньше или равен второму.
  - `JG`: Переход, если первый элемент стека больше второго.
  - `JGE`: Переход, если первый элемент стека больше или равен второму.
  - `JE`: Переход, если элементы стека равны.
  - `JNE`: Переход, если элементы стека не равны.
  - `CALL`: Вызов подпрограммы.
  - `RET`: Возврат из подпрограммы.

- **Графика**:
  - `DRAW`: Отрисовка графики с использованием SDL2.
  - `DRAWT`: Текстовая отрисовка.

- **Прочие**:
  - `HLT`: Остановка выполнения программы.
  - `MEOW`: Вывод строки "MEOW" заданное количество раз (для тестирования).

Файл со своим кодом рекомендуется помещать в папку `./assets`, а сам файл должен быть с расширением `.asm`. Менять имя входного и выходного файла можно через флаги компиляции (`-o [output_filename] -i [input_filename]`). Для ассемблера флаги нужно записывать в переменную `AOPTS`, а для процессора - `POPTS`.

## Как работает (+ фичи)

### Промежуточное представление

Ассемблерная часть генерирует бинарник с байт-кодом, который после этого исполняется процессорной частью. Такое разделение было сделано, для того чтобы не приходилось обрабатывать исходный текст с большим количеством бесполезной для исполнения информации при каждом запуске отдной  той же программы. В промежуточном представлении максимально компактно записываются инструкции. 

Каждая операция кодируется в виде последовательности байтов, где первый байт содержит информацию о типе операции и структуре операнда, а последующие байты содержат сами операнды (числа, регистры или их комбинации).

#### Структура первого байта

```
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---|---|---|---|---|---|---|---|
|       Opcode      | M | R | I |
```

- **Биты 0-4 (Opcode)**: Код операции (5 бит). Определяет, какая операция выполняется (например, `PUSH`, `ADD`, `JMP` и т.д.).
- **Бит 5 (M)**: Флаг памяти. Указывает, используется ли в операнде обращение к памяти (например, `[num]` или `[reg + num]`).
- **Бит 6 (R)**: Флаг регистра. Указывает, используется ли в операнде регистр (например, `reg` или `reg + num`).
- **Бит 7 (I)**: Флаг числа (константы). Указывает, используется ли в операнде число (например, `num` или `reg + num`).

### Кодогенерация и синхронизация операций

Для обеспечения органичности кода и избавления от дублирования используется прием кодогенерации. В файле `utils/commands.h` прописано раскрытие макроса `COMAND_HANDLE` при различных аргументах, который позволяет генерировать обработку команд на этапе компиляции. Это позволяет избежать написания run-time циклов и синхронизировать операции в ассемблере и процессоре. Такой подход упрощает добавление и изменение операций, так как все изменения вносятся в одном месте.

Пример использования кодогенерации:

```c
#define COMAND_HANDLE(cmd_name, ndo_it, do_it) \
    case OPCODE_##cmd_name: \
    { \
        do_it \
        break; \
    }

foo(...)
{
    ...
    switch(opcode)
    {
#include <./path/to/commands.h>     // Раскрывается в много case-блоков
    }
    ...
}
```

### Видео-память с использованием SDL2

В проекте реализована видео-память с использованием библиотеки SDL2. Это позволяет визуализировать выполнение программ, например, отрисовывать графику или выводить текстовую информацию на экран. Размеры памяти **60x60** пикселей